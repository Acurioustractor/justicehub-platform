/**\n * Geocoding API Endpoints\n * \n * Provides API endpoints for systematic geocoding operations\n */\n\nimport { Pool } from 'pg';\nimport pino from 'pino';\nimport { systematicGeocoding, analyzeGeocodingCoverage } from '../scripts/systematic-geocoding.js';\n\nconst logger = pino({ name: 'geocoding-api' });\n\n// Database connection\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  ssl: process.env.NODE_ENV === 'production' ? { rejectUnauthorized: false } : false\n});\n\n// Analyze current geocoding coverage\nexport async function getGeocodingAnalysis(req, res) {\n  try {\n    logger.info('Analyzing geocoding coverage');\n    \n    const coverage = await analyzeGeocodingCoverage();\n    \n    // Get additional statistics\n    const stateQuery = `\n      SELECT \n        location->>'state' as state,\n        COUNT(*) as total,\n        COUNT(CASE WHEN \n          (location->'coordinates'->>'lat') IS NOT NULL \n          AND (location->'coordinates'->>'lng') IS NOT NULL \n        THEN 1 END) as geocoded\n      FROM services \n      WHERE location IS NOT NULL\n      GROUP BY location->>'state'\n      ORDER BY COUNT(*) DESC\n    `;\n    \n    const stateResult = await pool.query(stateQuery);\n    const byState = stateResult.rows.map(row => ({\n      state: row.state || 'Unknown',\n      total: parseInt(row.total),\n      geocoded: parseInt(row.geocoded),\n      percentage: row.total > 0 ? (row.geocoded / row.total * 100).toFixed(1) : '0'\n    }));\n    \n    res.json({\n      success: true,\n      coverage: {\n        totalServices: parseInt(coverage.total_services),\n        geocodedServices: parseInt(coverage.geocoded_services),\n        servicesWithLocation: parseInt(coverage.services_with_location),\n        geocodingPercentage: parseFloat(coverage.geocoding_percentage),\n        missing: parseInt(coverage.services_with_location) - parseInt(coverage.geocoded_services)\n      },\n      byState,\n      recommendations: generateRecommendations(coverage, byState)\n    });\n    \n  } catch (error) {\n    logger.error({ error: error.message }, 'Failed to analyze geocoding coverage');\n    res.status(500).json({\n      success: false,\n      error: 'Failed to analyze geocoding coverage',\n      details: error.message\n    });\n  }\n}\n\n// Start systematic geocoding process\nexport async function startSystematicGeocoding(req, res) {\n  try {\n    const {\n      dryRun = false,\n      batchSize = 50,\n      maxServices = null,\n      onlyMissing = true\n    } = req.body || {};\n    \n    logger.info({ dryRun, batchSize, maxServices, onlyMissing }, 'Starting systematic geocoding via API');\n    \n    // Run geocoding process\n    const result = await systematicGeocoding({\n      dryRun,\n      batchSize,\n      maxServices,\n      onlyMissing\n    });\n    \n    res.json({\n      success: true,\n      message: dryRun ? 'Dry run completed' : 'Geocoding completed',\n      result: {\n        successful: result.success,\n        failed: result.failed,\n        skipped: result.skipped,\n        stats: result.stats\n      }\n    });\n    \n  } catch (error) {\n    logger.error({ error: error.message }, 'Systematic geocoding failed');\n    res.status(500).json({\n      success: false,\n      error: 'Systematic geocoding failed',\n      details: error.message\n    });\n  }\n}\n\n// Get geocoding status and progress\nexport async function getGeocodingStatus(req, res) {\n  try {\n    // Check if geocoding is currently running (simplified)\n    const query = `\n      SELECT \n        COUNT(*) as total,\n        COUNT(CASE WHEN location->'coordinates'->>'geocoded_at' IS NOT NULL THEN 1 END) as recently_geocoded,\n        MAX(CASE WHEN location->'coordinates'->>'geocoded_at' IS NOT NULL \n          THEN (location->'coordinates'->>'geocoded_at')::timestamp \n          ELSE NULL END) as last_geocoded\n      FROM services\n      WHERE location IS NOT NULL\n    `;\n    \n    const result = await pool.query(query);\n    const status = result.rows[0];\n    \n    res.json({\n      success: true,\n      status: {\n        isRunning: false, // Simplified - would need process tracking for real implementation\n        totalServices: parseInt(status.total),\n        recentlyGeocoded: parseInt(status.recently_geocoded),\n        lastGeocodedAt: status.last_geocoded,\n        progress: {\n          completed: parseInt(status.recently_geocoded),\n          total: parseInt(status.total),\n          percentage: status.total > 0 ? (status.recently_geocoded / status.total * 100).toFixed(1) : '0'\n        }\n      }\n    });\n    \n  } catch (error) {\n    logger.error({ error: error.message }, 'Failed to get geocoding status');\n    res.status(500).json({\n      success: false,\n      error: 'Failed to get geocoding status',\n      details: error.message\n    });\n  }\n}\n\n// Generate recommendations based on geocoding analysis\nfunction generateRecommendations(coverage, byState) {\n  const recommendations = [];\n  \n  const geocodingPercentage = parseFloat(coverage.geocoding_percentage);\n  const totalServices = parseInt(coverage.total_services);\n  const missing = parseInt(coverage.services_with_location) - parseInt(coverage.geocoded_services);\n  \n  if (geocodingPercentage < 50) {\n    recommendations.push({\n      type: 'urgent',\n      title: 'Low Geocoding Coverage',\n      message: `Only ${geocodingPercentage}% of services have coordinates. Run systematic geocoding to improve map coverage.`,\n      action: 'Start geocoding process'\n    });\n  } else if (geocodingPercentage < 80) {\n    recommendations.push({\n      type: 'warning',\n      title: 'Moderate Geocoding Coverage',\n      message: `${geocodingPercentage}% of services have coordinates. Consider running geocoding for the remaining ${missing} services.`,\n      action: 'Geocode missing services'\n    });\n  } else {\n    recommendations.push({\n      type: 'success',\n      title: 'Good Geocoding Coverage',\n      message: `${geocodingPercentage}% of services have coordinates. Good coverage for map display.`,\n      action: 'Monitor and maintain'\n    });\n  }\n  \n  // Check for states with poor coverage\n  const poorStates = byState.filter(state => parseFloat(state.percentage) < 50 && state.total > 10);\n  if (poorStates.length > 0) {\n    recommendations.push({\n      type: 'info',\n      title: 'State-Specific Issues',\n      message: `Low geocoding coverage in: ${poorStates.map(s => s.state).join(', ')}. Focus geocoding efforts on these states.`,\n      action: 'Target state-specific geocoding'\n    });\n  }\n  \n  if (totalServices > 1000) {\n    recommendations.push({\n      type: 'info',\n      title: 'Large Dataset',\n      message: `${totalServices} total services. Consider batch processing with smaller batch sizes for better performance.`,\n      action: 'Use batch processing'\n    });\n  }\n  \n  return recommendations;\n}\n\n// Express route handlers\nexport function setupGeocodingRoutes(app) {\n  app.get('/api/geocoding/analysis', getGeocodingAnalysis);\n  app.post('/api/geocoding/start', startSystematicGeocoding);\n  app.get('/api/geocoding/status', getGeocodingStatus);\n  \n  logger.info('Geocoding API routes registered');\n}\n