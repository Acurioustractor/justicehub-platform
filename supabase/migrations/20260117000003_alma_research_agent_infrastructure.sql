-- =============================================================================
-- ALMA Research Agent Infrastructure
-- =============================================================================
-- Purpose: Database tables and RPC functions for autonomous research system
-- Inspired by: Dexter financial research agent (github.com/virattt/dexter)
-- =============================================================================

-- -----------------------------------------------------------------------------
-- 1. RESEARCH SESSION TABLES
-- -----------------------------------------------------------------------------

-- Research sessions track autonomous research queries
CREATE TABLE IF NOT EXISTS alma_research_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  query TEXT NOT NULL,
  status TEXT DEFAULT 'pending' CHECK (status IN ('pending', 'planning', 'executing', 'validating', 'synthesizing', 'complete', 'failed')),
  depth TEXT DEFAULT 'quick' CHECK (depth IN ('quick', 'thorough', 'comprehensive')),

  -- Research plan generated by planning agent
  plan JSONB DEFAULT '[]'::JSONB,

  -- Scratchpad for intermediate results
  scratchpad JSONB DEFAULT '{}'::JSONB,

  -- Final research results
  results JSONB,

  -- Consent level for this research session
  max_consent_level TEXT DEFAULT 'Public Knowledge Commons'
    CHECK (max_consent_level IN ('Public Knowledge Commons', 'Community Controlled', 'Strictly Private')),

  -- Metadata
  user_id UUID REFERENCES auth.users(id),
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  completed_at TIMESTAMPTZ,

  -- Error tracking
  error_message TEXT,
  retry_count INT DEFAULT 0
);

-- Research findings discovered during research
CREATE TABLE IF NOT EXISTS alma_research_findings (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES alma_research_sessions(id) ON DELETE CASCADE,

  -- Finding classification
  finding_type TEXT NOT NULL CHECK (finding_type IN (
    'evidence_link',      -- New evidence to link
    'outcome_link',       -- New outcome to link
    'gap_identified',     -- Evidence gap found
    'verification',       -- Existing data verified
    'contradiction',      -- Data contradiction found
    'new_intervention',   -- New intervention discovered
    'external_source',    -- New external source to add
    'recommendation'      -- Research recommendation
  )),

  -- What entity this finding relates to
  entity_type TEXT,  -- 'intervention', 'evidence', 'outcome', etc.
  entity_id UUID,

  -- The actual finding content
  content JSONB NOT NULL,

  -- Confidence and validation
  confidence DECIMAL(3,2) CHECK (confidence >= 0 AND confidence <= 1),
  validated BOOLEAN DEFAULT FALSE,
  validation_source TEXT,

  -- Sources for this finding
  sources TEXT[],

  -- Whether this has been applied to ALMA data
  applied BOOLEAN DEFAULT FALSE,
  applied_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Research tool execution log
CREATE TABLE IF NOT EXISTS alma_research_tool_logs (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES alma_research_sessions(id) ON DELETE CASCADE,

  tool_name TEXT NOT NULL,
  tool_input JSONB,
  tool_output JSONB,

  execution_time_ms INT,
  success BOOLEAN,
  error_message TEXT,

  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- External sources cache (to avoid re-fetching)
CREATE TABLE IF NOT EXISTS alma_external_source_cache (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  url TEXT UNIQUE NOT NULL,
  content_hash TEXT,
  parsed_content JSONB,
  source_type TEXT, -- 'aihw', 'aic', 'pc', 'academic', 'government'

  fetched_at TIMESTAMPTZ DEFAULT NOW(),
  expires_at TIMESTAMPTZ DEFAULT NOW() + INTERVAL '7 days',

  -- Metadata extracted
  title TEXT,
  publication_date DATE,
  author TEXT
);

-- -----------------------------------------------------------------------------
-- 2. INDEXES FOR PERFORMANCE
-- -----------------------------------------------------------------------------

CREATE INDEX IF NOT EXISTS idx_research_sessions_status ON alma_research_sessions(status);
CREATE INDEX IF NOT EXISTS idx_research_sessions_user ON alma_research_sessions(user_id);
CREATE INDEX IF NOT EXISTS idx_research_sessions_created ON alma_research_sessions(created_at DESC);
CREATE INDEX IF NOT EXISTS idx_research_findings_session ON alma_research_findings(session_id);
CREATE INDEX IF NOT EXISTS idx_research_findings_type ON alma_research_findings(finding_type);
CREATE INDEX IF NOT EXISTS idx_research_findings_entity ON alma_research_findings(entity_type, entity_id);
CREATE INDEX IF NOT EXISTS idx_tool_logs_session ON alma_research_tool_logs(session_id);
CREATE INDEX IF NOT EXISTS idx_external_cache_url ON alma_external_source_cache(url);
CREATE INDEX IF NOT EXISTS idx_external_cache_expires ON alma_external_source_cache(expires_at);

-- -----------------------------------------------------------------------------
-- 3. RPC FUNCTIONS FOR RESEARCH TOOLS
-- -----------------------------------------------------------------------------

-- Tool: Search ALMA interventions with rich filters
CREATE OR REPLACE FUNCTION search_alma_interventions(
  p_query TEXT DEFAULT NULL,
  p_geography TEXT[] DEFAULT NULL,
  p_type TEXT DEFAULT NULL,
  p_evidence_level TEXT DEFAULT NULL,
  p_consent_level TEXT DEFAULT 'Public Knowledge Commons',
  p_limit INT DEFAULT 20
)
RETURNS TABLE (
  id UUID,
  name TEXT,
  type TEXT,
  description TEXT,
  geography TEXT,
  evidence_level TEXT,
  consent_level TEXT,
  operating_organization TEXT,
  evidence_count BIGINT,
  outcome_count BIGINT,
  relevance_score FLOAT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id,
    i.name,
    i.type,
    i.description,
    i.geography,
    i.evidence_level,
    i.consent_level,
    i.operating_organization,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    -- Simple relevance scoring
    CASE
      WHEN p_query IS NOT NULL THEN
        ts_rank(
          to_tsvector('english', COALESCE(i.name, '') || ' ' || COALESCE(i.description, '')),
          plainto_tsquery('english', p_query)
        )
      ELSE 1.0
    END::FLOAT as relevance_score
  FROM alma_interventions i
  WHERE
    -- Consent filter (always applied)
    (i.consent_level = 'Public Knowledge Commons' OR
     (p_consent_level IN ('Community Controlled', 'Strictly Private') AND i.consent_level = 'Community Controlled') OR
     (p_consent_level = 'Strictly Private' AND i.consent_level = 'Strictly Private'))
    -- Optional filters
    AND (p_query IS NULL OR
         to_tsvector('english', COALESCE(i.name, '') || ' ' || COALESCE(i.description, ''))
         @@ plainto_tsquery('english', p_query))
    AND (p_geography IS NULL OR i.geography = ANY(p_geography))
    AND (p_type IS NULL OR i.type = p_type)
    AND (p_evidence_level IS NULL OR i.evidence_level ILIKE '%' || p_evidence_level || '%')
  ORDER BY relevance_score DESC, evidence_count DESC
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Tool: Get comprehensive intervention data with all relationships
CREATE OR REPLACE FUNCTION get_intervention_comprehensive(p_intervention_id UUID)
RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'intervention', row_to_json(i),
    'evidence', COALESCE((
      SELECT jsonb_agg(row_to_json(e))
      FROM alma_intervention_evidence ie
      JOIN alma_evidence e ON e.id = ie.evidence_id
      WHERE ie.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'outcomes', COALESCE((
      SELECT jsonb_agg(row_to_json(o))
      FROM alma_intervention_outcomes io
      JOIN alma_outcomes o ON o.id = io.outcome_id
      WHERE io.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'contexts', COALESCE((
      SELECT jsonb_agg(row_to_json(c))
      FROM alma_intervention_contexts ic
      JOIN alma_contexts c ON c.id = ic.context_id
      WHERE ic.intervention_id = p_intervention_id
    ), '[]'::JSONB),
    'related_articles', COALESCE((
      SELECT jsonb_agg(jsonb_build_object(
        'title', a.title,
        'content_type', a.content_type,
        'slug', a.slug
      ))
      FROM article_related_interventions ari
      JOIN articles a ON a.id = ari.article_id
      WHERE ari.intervention_id = p_intervention_id
    ), '[]'::JSONB)
  ) INTO result
  FROM alma_interventions i
  WHERE i.id = p_intervention_id;

  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Tool: Find evidence gaps for interventions
CREATE OR REPLACE FUNCTION find_evidence_gaps(
  p_jurisdiction TEXT DEFAULT NULL,
  p_intervention_type TEXT DEFAULT NULL,
  p_limit INT DEFAULT 20
)
RETURNS TABLE (
  intervention_id UUID,
  intervention_name TEXT,
  intervention_type TEXT,
  geography TEXT,
  current_evidence_level TEXT,
  evidence_count BIGINT,
  outcome_count BIGINT,
  gap_severity TEXT,
  gap_description TEXT
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id as intervention_id,
    i.name as intervention_name,
    i.type as intervention_type,
    i.geography,
    i.evidence_level as current_evidence_level,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'critical'
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
        THEN 'high'
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'medium'
      ELSE 'low'
    END as gap_severity,
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'No evidence or outcome data linked'
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
        THEN 'No evidence research linked'
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0
        THEN 'No outcome measures linked'
      ELSE 'Has basic data, may need verification'
    END as gap_description
  FROM alma_interventions i
  WHERE
    i.consent_level = 'Public Knowledge Commons'
    AND (p_jurisdiction IS NULL OR i.geography = p_jurisdiction)
    AND (p_intervention_type IS NULL OR i.type = p_intervention_type)
  ORDER BY
    CASE
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0
           AND (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0 THEN 1
      WHEN (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) = 0 THEN 2
      WHEN (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) = 0 THEN 3
      ELSE 4
    END,
    i.name
  LIMIT p_limit;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Tool: Compare interventions
CREATE OR REPLACE FUNCTION compare_interventions(p_intervention_ids UUID[])
RETURNS TABLE (
  intervention_id UUID,
  name TEXT,
  type TEXT,
  geography TEXT,
  evidence_level TEXT,
  evidence_count BIGINT,
  outcome_count BIGINT,
  consent_level TEXT,
  cost_per_day DECIMAL,
  outcome_types TEXT[]
) AS $$
BEGIN
  RETURN QUERY
  SELECT
    i.id as intervention_id,
    i.name,
    i.type,
    i.geography,
    i.evidence_level,
    (SELECT COUNT(*) FROM alma_intervention_evidence ie WHERE ie.intervention_id = i.id) as evidence_count,
    (SELECT COUNT(*) FROM alma_intervention_outcomes io WHERE io.intervention_id = i.id) as outcome_count,
    i.consent_level,
    i.cost_per_participant_per_day as cost_per_day,
    (SELECT array_agg(DISTINCT o.outcome_type)
     FROM alma_intervention_outcomes io
     JOIN alma_outcomes o ON o.id = io.outcome_id
     WHERE io.intervention_id = i.id) as outcome_types
  FROM alma_interventions i
  WHERE i.id = ANY(p_intervention_ids)
  ORDER BY array_position(p_intervention_ids, i.id);
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Tool: Get jurisdiction statistics
CREATE OR REPLACE FUNCTION get_jurisdiction_stats(p_jurisdiction TEXT)
RETURNS JSONB AS $$
DECLARE
  result JSONB;
BEGIN
  SELECT jsonb_build_object(
    'jurisdiction', p_jurisdiction,
    'intervention_count', (
      SELECT COUNT(*) FROM alma_interventions
      WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
    ),
    'intervention_types', (
      SELECT jsonb_object_agg(type, cnt)
      FROM (
        SELECT type, COUNT(*) as cnt
        FROM alma_interventions
        WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
        GROUP BY type
      ) sub
    ),
    'evidence_levels', (
      SELECT jsonb_object_agg(COALESCE(evidence_level, 'Unknown'), cnt)
      FROM (
        SELECT evidence_level, COUNT(*) as cnt
        FROM alma_interventions
        WHERE geography = p_jurisdiction AND consent_level = 'Public Knowledge Commons'
        GROUP BY evidence_level
      ) sub
    ),
    'total_evidence_links', (
      SELECT COUNT(*)
      FROM alma_intervention_evidence ie
      JOIN alma_interventions i ON i.id = ie.intervention_id
      WHERE i.geography = p_jurisdiction
    ),
    'total_outcome_links', (
      SELECT COUNT(*)
      FROM alma_intervention_outcomes io
      JOIN alma_interventions i ON i.id = io.intervention_id
      WHERE i.geography = p_jurisdiction
    )
  ) INTO result;

  RETURN result;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 4. RESEARCH SESSION MANAGEMENT FUNCTIONS
-- -----------------------------------------------------------------------------

-- Create a new research session
CREATE OR REPLACE FUNCTION create_research_session(
  p_query TEXT,
  p_depth TEXT DEFAULT 'quick',
  p_max_consent_level TEXT DEFAULT 'Public Knowledge Commons',
  p_user_id UUID DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_session_id UUID;
BEGIN
  INSERT INTO alma_research_sessions (query, depth, max_consent_level, user_id, status)
  VALUES (p_query, p_depth, p_max_consent_level, p_user_id, 'pending')
  RETURNING id INTO v_session_id;

  RETURN v_session_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Update research session status
CREATE OR REPLACE FUNCTION update_research_session(
  p_session_id UUID,
  p_status TEXT DEFAULT NULL,
  p_plan JSONB DEFAULT NULL,
  p_scratchpad JSONB DEFAULT NULL,
  p_results JSONB DEFAULT NULL,
  p_error_message TEXT DEFAULT NULL
)
RETURNS VOID AS $$
BEGIN
  UPDATE alma_research_sessions
  SET
    status = COALESCE(p_status, status),
    plan = COALESCE(p_plan, plan),
    scratchpad = COALESCE(p_scratchpad, scratchpad),
    results = COALESCE(p_results, results),
    error_message = COALESCE(p_error_message, error_message),
    updated_at = NOW(),
    completed_at = CASE WHEN p_status IN ('complete', 'failed') THEN NOW() ELSE completed_at END
  WHERE id = p_session_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Log tool execution
CREATE OR REPLACE FUNCTION log_research_tool(
  p_session_id UUID,
  p_tool_name TEXT,
  p_tool_input JSONB,
  p_tool_output JSONB,
  p_execution_time_ms INT,
  p_success BOOLEAN,
  p_error_message TEXT DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_log_id UUID;
BEGIN
  INSERT INTO alma_research_tool_logs (
    session_id, tool_name, tool_input, tool_output,
    execution_time_ms, success, error_message
  )
  VALUES (
    p_session_id, p_tool_name, p_tool_input, p_tool_output,
    p_execution_time_ms, p_success, p_error_message
  )
  RETURNING id INTO v_log_id;

  RETURN v_log_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Record a research finding
CREATE OR REPLACE FUNCTION record_research_finding(
  p_session_id UUID,
  p_finding_type TEXT,
  p_content JSONB,
  p_entity_type TEXT DEFAULT NULL,
  p_entity_id UUID DEFAULT NULL,
  p_confidence DECIMAL DEFAULT NULL,
  p_sources TEXT[] DEFAULT NULL
)
RETURNS UUID AS $$
DECLARE
  v_finding_id UUID;
BEGIN
  INSERT INTO alma_research_findings (
    session_id, finding_type, content, entity_type,
    entity_id, confidence, sources
  )
  VALUES (
    p_session_id, p_finding_type, p_content, p_entity_type,
    p_entity_id, p_confidence, p_sources
  )
  RETURNING id INTO v_finding_id;

  RETURN v_finding_id;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- -----------------------------------------------------------------------------
-- 5. ENABLE RLS
-- -----------------------------------------------------------------------------

ALTER TABLE alma_research_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE alma_research_findings ENABLE ROW LEVEL SECURITY;
ALTER TABLE alma_research_tool_logs ENABLE ROW LEVEL SECURITY;
ALTER TABLE alma_external_source_cache ENABLE ROW LEVEL SECURITY;

-- Public read for research sessions (findings are consent-aware)
CREATE POLICY "Public read research sessions" ON alma_research_sessions
  FOR SELECT USING (true);

CREATE POLICY "Authenticated create sessions" ON alma_research_sessions
  FOR INSERT WITH CHECK (true);

CREATE POLICY "Session owners can update" ON alma_research_sessions
  FOR UPDATE USING (auth.uid() = user_id OR user_id IS NULL);

-- Findings follow session consent
CREATE POLICY "Public read findings" ON alma_research_findings
  FOR SELECT USING (true);

CREATE POLICY "Authenticated create findings" ON alma_research_findings
  FOR INSERT WITH CHECK (true);

-- Tool logs are internal
CREATE POLICY "Public read tool logs" ON alma_research_tool_logs
  FOR SELECT USING (true);

CREATE POLICY "System insert tool logs" ON alma_research_tool_logs
  FOR INSERT WITH CHECK (true);

-- Cache is shared
CREATE POLICY "Public read cache" ON alma_external_source_cache
  FOR SELECT USING (true);

CREATE POLICY "System manage cache" ON alma_external_source_cache
  FOR ALL USING (true);

-- -----------------------------------------------------------------------------
-- 6. SUMMARY
-- -----------------------------------------------------------------------------

DO $$
BEGIN
  RAISE NOTICE '=== ALMA Research Agent Infrastructure Complete ===';
  RAISE NOTICE 'Tables created:';
  RAISE NOTICE '  - alma_research_sessions (research query tracking)';
  RAISE NOTICE '  - alma_research_findings (discovered findings)';
  RAISE NOTICE '  - alma_research_tool_logs (tool execution log)';
  RAISE NOTICE '  - alma_external_source_cache (external data cache)';
  RAISE NOTICE '';
  RAISE NOTICE 'RPC Functions created:';
  RAISE NOTICE '  - search_alma_interventions (filtered intervention search)';
  RAISE NOTICE '  - get_intervention_comprehensive (full intervention data)';
  RAISE NOTICE '  - find_evidence_gaps (identify missing data)';
  RAISE NOTICE '  - compare_interventions (side-by-side comparison)';
  RAISE NOTICE '  - get_jurisdiction_stats (jurisdiction overview)';
  RAISE NOTICE '  - create_research_session (start research)';
  RAISE NOTICE '  - update_research_session (update progress)';
  RAISE NOTICE '  - log_research_tool (log tool execution)';
  RAISE NOTICE '  - record_research_finding (store findings)';
END;
$$;

-- =============================================================================
-- MIGRATION COMPLETE
-- =============================================================================
